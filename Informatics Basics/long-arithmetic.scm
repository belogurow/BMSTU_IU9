(define (perevod x)
  (- (char->integer x) 48))
(define (perevodobr x)
  (integer->char (+ x 48)))

(define (s->l s)
  (string->list s))

(define (l->s l)
  (list->string l))
;-----------------l+
(define (l+ . args)
  (define (iter sum1 xs)
    (if (not (null? xs))
        (iter (sum sum1 (car xs) 0 '()) (cdr xs))
        sum1))
  (iter '() args))

(define (sum x y r spis)
  (if (and (null? x) (null? y))
      (if (equal? r 1)
          (append (list (perevodobr r)) spis)
          spis)
      (let ((a1 (if (null? x) 0 (perevod (car (reverse x)))))
            (a2 (if (null? x) '() (reverse (cdr (reverse x)))))
            (b1 (if (null? y) 0 (perevod (car (reverse y)))))
            (b2 (if (null? y) '() (reverse (cdr (reverse y))))))
        (if (> (+ a1 b1 r) 9)
            (sum a2 b2 1 (append (list (perevodobr (remainder (+ a1 b1 r) 10))) spis))
            (sum a2 b2 0 (append (list (perevodobr (+ a1 b1 r))) spis))))))
;------------------l-           
(define (l- . args)
  (define (iter razn1 xs)
    (if (not (null? xs))
        (iter (razn razn1 (car xs) 0 '()) (cdr xs))
        razn1))
  (iter (car args) (cdr args)))
  
(define (razn x y r spis)
  (if (null? x)
      (if (equal? (car spis) #\0) 
          (cdr spis)
          spis)
      (let ((a1 (if (null? x) 0 (perevod (car (reverse x)))))
            (a2 (if (null? x) '() (reverse (cdr (reverse x)))))
            (b1 (if (null? y) 0 (perevod (car (reverse y)))))
            (b2 (if (null? y) '() (reverse (cdr (reverse y))))))
        (if (< (- a1 b1 r) 0)
            (razn a2 b2 1 (append (list (perevodobr (- (+ 10 a1) b1 r))) spis))
            (razn a2 b2 0 (append (list (perevodobr (- a1 b1 r))) spis))))))
;-------------l*
(define (l* . args)
  (define (iter razn1 xs)
    (if (not (null? xs))
        (iter (prog 0 razn1 (car xs) '()) (cdr xs))
        razn1))
  (iter (car args) (cdr args)))

(define (razr xs r)
  (if (equal? r 0)
      xs
      (razr (append xs (list #\0)) (- r 1))))

(define (multi x y r spis)
  (if (null? x)
      (if (equal? r 0)
          spis
          (append (list (perevodobr r)) spis))
      (let ((a1 (if (null? x) 0 (perevod (car (reverse x)))))
            (a2 (if (null? x) '() (reverse (cdr (reverse x)))))
            (b1 (if (null? y) 0 (perevod (car (reverse y))))))
        (if (>= (+ (* a1 b1) r) 10)
            (multi a2 y (quotient (+ (* a1 b1) r) 10) (append (list (perevodobr (remainder (+ (* a1 b1) r) 10))) spis))
            (multi a2 y 0 (append (list (perevodobr (+ (* a1 b1) r))) spis))))))

 (define (prog i xs ys spis)
  (if (not (null? ys))
      (prog (+ i 1) xs (reverse (cdr (reverse ys))) (l+ spis (razr (multi xs (list (car (reverse ys))) 0 '()) i)))
      spis))
;-------------l=
(define (l= . args)
  (if (null? (cdr args))
      (null? (cdr args))
      (if (equal? (car args) (car (cdr args)))
          (l= (cdr args))
          (equal? (car args) (car (cdr args))))))
;--------------l/
(define (del2 xs r spis)
  (if (null? xs)
      (if (equal? (car spis) #\0)
          (cdr spis)
          spis)
      (let* ((a (perevod (car xs)))
             (a1 (cdr xs))
             (r1 (+ (* r 10) a)))
        (del2 a1 (remainder r1 2) (append spis (list (perevodobr (quotient r1 2))))))))

(define (sr a b)
  (if (and (null? a) (null? b))
      (not (null? a))      
  (let* ((al (length a))
        (bl (length b))
        (a1 (perevod (car a)))
        (b1 (perevod (car b))))
    (if (equal? al bl)
        (if (equal? a1 b1)
            (sr (cdr a) (cdr b))
            (> a1 b1))
        (> al bl)))))
                  
(define (del a b x b1)  
  (let* ((m (del2 (l+ a b) 0 '()))
         (mm (l* x m)))
    (if (sr (l- b (s->l "1")) a)
        (if (sr mm b1)
            (del a m x b1)
            (del m b x b1))
        m)))

(define (l-quotient a b)
  (del (s->l "0") a b a))

(define (without0 a)
  (if (not (null? a))
      (if (equal? (car a) #\0)
          (without0 (cdr a))
          (cons (car a) (without0 (cdr a))))
      '()))
(define (l-remainder a b) 
  (without0 (l- a (l* (l-quotient a b) b))))
;-------------l-factorial
(define (l-factorial a)
  (define (iter a i)
    (if (and (equal? a (s->l "0")) (equal? i (s->l "1")))
        i
        (if (equal? a (s->l "1"))
            i        
            (iter (l- a (s->l "1")) (l* i a)))))
  (iter a (s->l "1")))

